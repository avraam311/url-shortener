// Code generated by MockGen. DO NOT EDIT.
// Source: service.go

// Package mock_url is a generated GoMock package.
package mock_url

import (
	context "context"
	reflect "reflect"

	domain "github.com/avraam311/url-shortener/internal/models/domain"
	gomock "github.com/golang/mock/gomock"
	retry "github.com/wb-go/wbf/retry"
)

// MockRepositoryURL is a mock of RepositoryURL interface.
type MockRepositoryURL struct {
	ctrl     *gomock.Controller
	recorder *MockRepositoryURLMockRecorder
}

// MockRepositoryURLMockRecorder is the mock recorder for MockRepositoryURL.
type MockRepositoryURLMockRecorder struct {
	mock *MockRepositoryURL
}

// NewMockRepositoryURL creates a new mock instance.
func NewMockRepositoryURL(ctrl *gomock.Controller) *MockRepositoryURL {
	mock := &MockRepositoryURL{ctrl: ctrl}
	mock.recorder = &MockRepositoryURLMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepositoryURL) EXPECT() *MockRepositoryURLMockRecorder {
	return m.recorder
}

// CheckIfShortURLIsUnique mocks base method.
func (m *MockRepositoryURL) CheckIfShortURLIsUnique(arg0 context.Context, arg1 string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CheckIfShortURLIsUnique", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CheckIfShortURLIsUnique indicates an expected call of CheckIfShortURLIsUnique.
func (mr *MockRepositoryURLMockRecorder) CheckIfShortURLIsUnique(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckIfShortURLIsUnique", reflect.TypeOf((*MockRepositoryURL)(nil).CheckIfShortURLIsUnique), arg0, arg1)
}

// GetFullURL mocks base method.
func (m *MockRepositoryURL) GetFullURL(arg0 context.Context, arg1 string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetFullURL", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetFullURL indicates an expected call of GetFullURL.
func (mr *MockRepositoryURLMockRecorder) GetFullURL(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFullURL", reflect.TypeOf((*MockRepositoryURL)(nil).GetFullURL), arg0, arg1)
}

// SaveShortURL mocks base method.
func (m *MockRepositoryURL) SaveShortURL(arg0 context.Context, arg1 *domain.URL) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SaveShortURL", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SaveShortURL indicates an expected call of SaveShortURL.
func (mr *MockRepositoryURLMockRecorder) SaveShortURL(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveShortURL", reflect.TypeOf((*MockRepositoryURL)(nil).SaveShortURL), arg0, arg1)
}

// Mockcache is a mock of cache interface.
type Mockcache struct {
	ctrl     *gomock.Controller
	recorder *MockcacheMockRecorder
}

// MockcacheMockRecorder is the mock recorder for Mockcache.
type MockcacheMockRecorder struct {
	mock *Mockcache
}

// NewMockcache creates a new mock instance.
func NewMockcache(ctrl *gomock.Controller) *Mockcache {
	mock := &Mockcache{ctrl: ctrl}
	mock.recorder = &MockcacheMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockcache) EXPECT() *MockcacheMockRecorder {
	return m.recorder
}

// GetWithRetry mocks base method.
func (m *Mockcache) GetWithRetry(ctx context.Context, strategy retry.Strategy, key string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetWithRetry", ctx, strategy, key)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetWithRetry indicates an expected call of GetWithRetry.
func (mr *MockcacheMockRecorder) GetWithRetry(ctx, strategy, key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWithRetry", reflect.TypeOf((*Mockcache)(nil).GetWithRetry), ctx, strategy, key)
}

// SetWithRetry mocks base method.
func (m *Mockcache) SetWithRetry(ctx context.Context, strategy retry.Strategy, key string, value interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetWithRetry", ctx, strategy, key, value)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetWithRetry indicates an expected call of SetWithRetry.
func (mr *MockcacheMockRecorder) SetWithRetry(ctx, strategy, key, value interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetWithRetry", reflect.TypeOf((*Mockcache)(nil).SetWithRetry), ctx, strategy, key, value)
}
